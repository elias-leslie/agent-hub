"""
TOON (Tiny Object Notation) formatting for adaptive index.

Provides compressed index format for memory injection.
"""

from typing import Any


def generate_toon_entry(uuid: str, summary: str | None = None, content: str | None = None) -> str:
    """
    Generate a TOON index entry for an episode.

    Format: uuid8:summary

    Uses stored summary if available, otherwise falls back to first 20 chars of content.
    The summary should be a ~20 char action phrase generated by Claude at save time.

    Args:
        uuid: Full episode UUID (only first 8 chars used)
        summary: Pre-computed summary from episode storage (preferred)
        content: Episode content (fallback only)

    Returns:
        TOON entry like "f87cbb18:use dt for checks"
    """
    if summary:
        display = summary[:25]
    elif content:
        display = content.replace("\n", " ").strip()[:25]
        if len(content) > 25:
            display = display.rsplit(" ", 1)[0] + "..."
    else:
        display = "no summary"
    return f"{uuid[:8]}:{display}"


async def build_toon_index(
    mandates: list[dict[str, Any]],
    guardrails: list[dict[str, Any]],
) -> str:
    """
    Build TOON-formatted compressed index for injection.

    Returns index string in format:
    MEM_IDX[N]:mandates
    uuid8:summary
    ...
    GUARDRAILS[N]
    uuid8:summary
    ...

    Plus retrieval instruction.
    """
    lines = [
        "IMPORTANT: Use retrieval-led reasoning. Search before acting.",
        "`st memory search <query>` - find relevant rules",
        "`st memory get <uuid8>` - get full content",
        "",
    ]

    if mandates:
        lines.append(f"MEM_IDX[{len(mandates)}]:mandates")
        for m in mandates:
            uuid = m.get("uuid", "")
            summary = m.get("summary")
            content = m.get("content", "")
            if uuid:
                lines.append(generate_toon_entry(uuid, summary=summary, content=content))
        lines.append("")

    if guardrails:
        lines.append(f"GUARDRAILS[{len(guardrails)}]")
        for g in guardrails:
            uuid = g.get("uuid", "")
            summary = g.get("summary")
            content = g.get("content", "")
            if uuid:
                lines.append(generate_toon_entry(uuid, summary=summary, content=content))

    return "\n".join(lines)
